"""
Vulnerability Analysis Module

This module provides tools for analyzing cybersecurity vulnerabilities
in solar inverters and distributed energy systems. It includes functionality
for CVE database management, protocol vulnerability assessment, and 
firmware security analysis.

Key Components:
- VulnerabilityAnalyzer: Main analysis engine
- CVEDatabase: CVE data management and querying
- ProtocolAnalyzer: Communication protocol security assessment
- FirmwareAnalyzer: Embedded system security evaluation
"""

import json
import logging
import pandas as pd
import requests
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum

# Configure logging
logger = logging.getLogger(__name__)

class SeverityLevel(Enum):
    """Vulnerability severity levels based on CVSS scoring."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH" 
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFORMATIONAL = "INFO"

class VulnerabilityAnalyzer:
    """
    Main vulnerability analysis engine for solar inverter systems.
    
    This class orchestrates the entire vulnerability assessment process,
    demonstrating backend architecture patterns like:
    - Dependency injection
    - Strategy pattern (different analysis methods)
    - Observer pattern (progress reporting)
    - Factory pattern (creating different analyzers)
    """
    
    def __init__(self, config_path: str = "config/system_components.json"):
        self.config_path = Path(config_path)
        self.cve_database = CVEDatabase()
        self.protocol_analyzer = ProtocolAnalyzer()
        self.firmware_analyzer = FirmwareAnalyzer()
        self.results = {}
        
        # Load system configuration
        self._load_configuration()
    
    def _load_configuration(self) -> None:
        """Load system configuration from JSON file."""
        try:
            if self.config_path.exists():
                with open(self.config_path, 'r') as f:
                    self.config = json.load(f)
            else:
                # Create default configuration
                self.config = self._create_default_config()
                self._save_configuration()
        except Exception as e:
            logger.error(f"Error loading configuration: {e}")
            self.config = self._create_default_config()
    
    def _create_default_config(self) -> Dict[str, Any]:
        """Create default system configuration."""
        return {
            "system_name": "Solar Inverter Network",
            "location": "Adelaide, South Australia",
            "components": [
                {
                    "id": "inverter_001",
                    "type": "solar_inverter",
                    "manufacturer": "sungrow",
                    "model": "SG5KTL",
                    "firmware_version": "1.0.3",
                    "protocols": ["modbus", "mqtt", "https"],
                    "network_interfaces": ["ethernet", "wifi"],
                    "api_endpoints": ["/api/v1/status", "/api/v1/control"]
                },
                {
                    "id": "communication_gateway",
                    "type": "gateway",
                    "manufacturer": "generic",
                    "model": "IoT-GW-001",
                    "protocols": ["mqtt", "https", "modbus"],
                    "features": ["data_aggregation", "remote_control"]
                }
            ],
            "network_topology": {
                "internet_facing": True,
                "firewall_enabled": False,
                "network_segmentation": False,
                "vpn_access": False
            },
            "compliance_requirements": {
                "aemo_vpp": True,
                "as4777": True,
                "iec61850": False
            }
        }
    
    def _save_configuration(self) -> None:
        """Save configuration to file."""
        try:
            self.config_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.config_path, 'w') as f:
                json.dump(self.config, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving configuration: {e}")
    
    def run_comprehensive_analysis(self) -> Dict[str, Any]:
        """
        Run comprehensive vulnerability analysis on the entire system.
        
        Returns:
            Complete analysis results including all vulnerability types
        """
        logger.info("Starting comprehensive vulnerability analysis")
        
        # 1. Update CVE database
        logger.info("Updating CVE database...")
        manufacturers = [comp["manufacturer"] for comp in self.config["components"]]
        new_cves = self.cve_database.fetch_solar_inverter_cves(manufacturers)
        
        # 2. Analyze known vulnerabilities
        logger.info("Analyzing known vulnerabilities...")
        vulnerability_results = self._analyze_known_vulnerabilities()
        
        # 3. Analyze protocol security
        logger.info("Analyzing protocol security...")
        protocol_results = self._analyze_protocol_security()
        
        # 4. Analyze firmware security
        logger.info("Analyzing firmware security...")
        firmware_results = self._analyze_firmware_security()
        
        # 5. Analyze network security
        logger.info("Analyzing network security...")
        network_results = self._analyze_network_security()
        
        # 6. Calculate overall risk score
        logger.info("Calculating risk scores...")
        risk_score = self._calculate_overall_risk(
            vulnerability_results, protocol_results, 
            firmware_results, network_results
        )
        
        # Compile comprehensive results
        self.results = {
            "analysis_timestamp": datetime.now().isoformat(),
            "system_info": {
                "name": self.config["system_name"],
                "location": self.config["location"],
                "components_analyzed": len(self.config["components"])
            },
            "cve_analysis": {
                "new_cves_found": new_cves,
                "total_vulnerabilities": len(self.cve_database.vulnerabilities),
                "results": vulnerability_results
            },
            "protocol_analysis": protocol_results,
            "firmware_analysis": firmware_results,
            "network_analysis": network_results,
            "risk_assessment": {
                "overall_score": risk_score,
                "risk_level": self._get_risk_level(risk_score),
                "recommendations": self._generate_recommendations()
            }
        }
        
        logger.info("Vulnerability analysis completed")
        return self.results
    
    def _analyze_known_vulnerabilities(self) -> Dict[str, Any]:
        """Analyze system against known CVE database."""
        results = {
            "critical_vulnerabilities": [],
            "high_vulnerabilities": [],
            "medium_vulnerabilities": [],
            "low_vulnerabilities": [],
            "affected_components": {}
        }
        
        for component in self.config["components"]:
            manufacturer = component["manufacturer"]
            model = component["model"]
            
            # Query CVEs for this manufacturer
            manufacturer_cves = self.cve_database.query_by_manufacturer(manufacturer)
            
            for vuln in manufacturer_cves:
                # Check if this specific model/firmware is affected
                if model in vuln.model or "Multiple Models" in vuln.model:
                    severity_key = f"{vuln.severity.value.lower()}_vulnerabilities"
                    if severity_key in results:
                        results[severity_key].append({
                            "cve_id": vuln.cve_id,
                            "title": vuln.title,
                            "cvss_score": vuln.cvss_score,
                            "affected_component": component["id"],
                            "mitigation_available": vuln.mitigation_available
                        })
                    
                    # Track affected components
                    comp_id = component["id"]
                    if comp_id not in results["affected_components"]:
                        results["affected_components"][comp_id] = []
                    results["affected_components"][comp_id].append(vuln.cve_id)
        
        return results
    
    def _analyze_protocol_security(self) -> Dict[str, Any]:
        """Analyze security of communication protocols used."""
        protocol_results = {}
        
        # Collect all protocols used across components
        protocols_used = set()
        for component in self.config["components"]:
            protocols_used.update(component.get("protocols", []))
        
        for protocol in protocols_used:
            # Get protocol configuration (mock configuration for demo)
            protocol_config = self._get_protocol_config(protocol)
            
            try:
                analysis = self.protocol_analyzer.analyze_protocol_security(
                    protocol, protocol_config
                )
                protocol_results[protocol] = analysis
            except ValueError as e:
                logger.warning(f"Could not analyze protocol {protocol}: {e}")
                protocol_results[protocol] = {
                    "protocol": protocol,
                    "security_score": 0,
                    "issues": [f"Unsupported protocol: {protocol}"],
                    "recommendations": ["Review protocol security manually"],
                    "risk_level": "UNKNOWN"
                }
        
        return protocol_results
    
    def _get_protocol_config(self, protocol: str) -> Dict[str, Any]:
        """Get protocol configuration (mock data for demonstration)."""
        # In a real implementation, this would query actual device configurations
        protocol_configs = {
            "modbus": {
                "encryption_enabled": False,
                "authentication_required": False,
                "open_access": True,
                "port": 502
            },
            "mqtt": {
                "tls_enabled": False,
                "username_password": True,
                "cert_validation": False,
                "port": 1883
            },
            "http": {
                "basic_auth": True,
                "port": 80
            },
            "https": {
                "tls_version": "1.2",
                "cert_validation": True,
                "weak_ciphers": False,
                "port": 443
            }
        }
        
        return protocol_configs.get(protocol, {})
    
    def _analyze_firmware_security(self) -> Dict[str, Any]:
        """Analyze firmware security across all components."""
        firmware_results = []
        
        for component in self.config["components"]:
            if "firmware_version" in component:
                analysis = self.firmware_analyzer.analyze_firmware(
                    component["manufacturer"],
                    component["model"], 
                    component["firmware_version"]
                )
                analysis["component_id"] = component["id"]
                firmware_results.append(analysis)
        
        return {
            "components_analyzed": len(firmware_results),
            "results": firmware_results,
            "summary": self._summarize_firmware_results(firmware_results)
        }
    
    def _analyze_network_security(self) -> Dict[str, Any]:
        """Analyze network security configuration."""
        network_config = self.config.get("network_topology", {})
        
        issues = []
        recommendations = []
        
        if network_config.get("internet_facing", False):
            if not network_config.get("firewall_enabled", False):
                issues.append("Internet-facing system without firewall protection")
                recommendations.append("Enable and configure firewall rules")
        
        if not network_config.get("network_segmentation", False):
            issues.append("No network segmentation implemented")
            recommendations.append("Implement network segmentation for IoT devices")
        
        if not network_config.get("vpn_access", False):
            issues.append("No VPN access for remote management")
            recommendations.append("Implement VPN for secure remote access")
        
        return {
            "configuration": network_config,
            "security_score": max(0, 10 - len(issues) * 2),
            "issues": issues,
            "recommendations": recommendations,
            "risk_level": "HIGH" if len(issues) >= 2 else "MEDIUM"
        }
    
    def _calculate_overall_risk(self, vuln_results: Dict, protocol_results: Dict,
                              firmware_results: Dict, network_results: Dict) -> float:
        """Calculate overall system risk score (0-10, where 10 is highest risk)."""
        # Weight different analysis components
        weights = {
            "vulnerabilities": 0.4,
            "protocols": 0.3,
            "firmware": 0.2,
            "network": 0.1
        }
        
        # Calculate vulnerability risk
        vuln_risk = 0
        critical_count = len(vuln_results.get("critical_vulnerabilities", []))
        high_count = len(vuln_results.get("high_vulnerabilities", []))
        vuln_risk = min(10, critical_count * 3 + high_count * 2)
        
        # Calculate protocol risk (average of protocol security scores)
        protocol_scores = [
            10 - result.get("security_score", 0) 
            for result in protocol_results.values()
        ]
        protocol_risk = sum(protocol_scores) / len(protocol_scores) if protocol_scores else 0
        
        # Calculate firmware risk
        firmware_scores = [
            10 - result.get("security_score", 0)
            for result in firmware_results.get("results", [])
        ]
        firmware_risk = sum(firmware_scores) / len(firmware_scores) if firmware_scores else 0
        
        # Calculate network risk
        network_risk = 10 - network_results.get("security_score", 0)
        
        # Weighted average
        overall_risk = (
            vuln_risk * weights["vulnerabilities"] +
            protocol_risk * weights["protocols"] +
            firmware_risk * weights["firmware"] +
            network_risk * weights["network"]
        )
        
        return round(overall_risk, 2)
    
    def _get_risk_level(self, risk_score: float) -> str:
        """Convert numeric risk score to risk level."""
        if risk_score >= 8:
            return "CRITICAL"
        elif risk_score >= 6:
            return "HIGH"
        elif risk_score >= 4:
            return "MEDIUM"
        elif risk_score >= 2:
            return "LOW"
        else:
            return "MINIMAL"
    
    def _generate_recommendations(self) -> List[str]:
        """Generate prioritized security recommendations."""
        recommendations = [
            "Update all firmware to latest versions",
            "Implement TLS encryption for all communications",
            "Change default credentials on all devices",
            "Enable network segmentation for IoT devices",
            "Implement regular security monitoring",
            "Establish incident response procedures",
            "Conduct regular penetration testing",
            "Implement API rate limiting and authentication"
        ]
        return recommendations
    
    def _summarize_firmware_results(self, firmware_results: List[Dict]) -> Dict[str, Any]:
        """Summarize firmware analysis results."""
        if not firmware_results:
            return {"message": "No firmware analyzed"}
        
        avg_score = sum(r.get("security_score", 0) for r in firmware_results) / len(firmware_results)
        outdated_count = sum(1 for r in firmware_results if r.get("outdated", False))
        
        return {
            "average_security_score": round(avg_score, 2),
            "outdated_firmware_count": outdated_count,
            "total_components": len(firmware_results)
        }
    
    def export_results(self, output_path: str = "outputs/vulnerability_report.json") -> None:
        """Export analysis results to JSON file."""
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        logger.info(f"Results exported to {output_path}")

class FirmwareAnalyzer:
    """
    Analyzes firmware security for solar inverter systems.
    
    This class demonstrates embedded systems security concepts:
    - Firmware version tracking and vulnerability mapping
    - Security feature detection
    - Update mechanism analysis
    """
    
    def __init__(self):
        self.firmware_database = self._load_firmware_database()
    
    def _load_firmware_database(self) -> Dict[str, Any]:
        """Load firmware vulnerability database."""
        # In a real implementation, this would load from a proper database
        return {
            "sungrow": {
                "SG5KTL": {
                    "1.0.0": {"security_score": 3, "vulnerabilities": ["CVE-2023-1001"]},
                    "1.0.1": {"security_score": 4, "vulnerabilities": ["CVE-2023-1001"]},
                    "1.0.2": {"security_score": 6, "vulnerabilities": []},
                    "1.0.3": {"security_score": 8, "vulnerabilities": []},
                    "latest": "1.0.3"
                }
            },
            "generic": {
                "IoT-GW-001": {
                    "1.0.0": {"security_score": 2, "vulnerabilities": ["Default credentials"]},
                    "2.0.0": {"security_score": 7, "vulnerabilities": []},
                    "latest": "2.0.0"
                }
            }
        }
    
    def analyze_firmware(self, manufacturer: str, model: str, version: str) -> Dict[str, Any]:
        """
        Analyze specific firmware version for security issues.
        
        Args:
            manufacturer: Device manufacturer
            model: Device model
            version: Firmware version
            
        Returns:
            Firmware security analysis results
        """
        manufacturer_data = self.firmware_database.get(manufacturer, {})
        model_data = manufacturer_data.get(model, {})
        
        if not model_data:
            return {
                "manufacturer": manufacturer,
                "model": model,
                "version": version,
                "security_score": 0,
                "analysis_status": "No firmware data available",
                "recommendations": ["Contact manufacturer for security information"]
            }
        
        version_data = model_data.get(version, {})
        latest_version = model_data.get("latest", "Unknown")
        
        is_outdated = version != latest_version
        security_score = version_data.get("security_score", 0)
        vulnerabilities = version_data.get("vulnerabilities", [])
        
        recommendations = []
        if is_outdated:
            recommendations.append(f"Update firmware to latest version ({latest_version})")
        if vulnerabilities:
            recommendations.append("Address known vulnerabilities listed")
        if security_score < 5:
            recommendations.append("Consider replacing with more secure alternative")
        
        return {
            "manufacturer": manufacturer,
            "model": model,
            "version": version,
            "latest_version": latest_version,
            "outdated": is_outdated,
            "security_score": security_score,
            "vulnerabilities": vulnerabilities,
            "recommendations": recommendations,
            "analysis_status": "Complete"
        }

# Example usage and testing functions
def main():
    """Main function for testing the vulnerability analysis module."""
    # Initialize analyzer
    analyzer = VulnerabilityAnalyzer()
    
    # Run comprehensive analysis
    results = analyzer.run_comprehensive_analysis()
    
    # Export results
    analyzer.export_results()
    
    # Print summary
    print(f"Analysis completed!")
    print(f"Overall risk score: {results['risk_assessment']['overall_score']}")
    print(f"Risk level: {results['risk_assessment']['risk_level']}")
    print(f"CVEs found: {results['cve_analysis']['total_vulnerabilities']}")

if __name__ == "__main__":
    main()

class VulnerabilityType(Enum):
    """Types of vulnerabilities commonly found in solar inverters."""
    DEFAULT_CREDENTIALS = "DEFAULT_CREDENTIALS"
    HARDCODED_SECRETS = "HARDCODED_SECRETS"
    WEAK_ENCRYPTION = "WEAK_ENCRYPTION"
    INSECURE_PROTOCOL = "INSECURE_PROTOCOL"
    INSUFFICIENT_AUTHENTICATION = "INSUFFICIENT_AUTHENTICATION"
    CODE_INJECTION = "CODE_INJECTION"
    BUFFER_OVERFLOW = "BUFFER_OVERFLOW"
    PRIVILEGE_ESCALATION = "PRIVILEGE_ESCALATION"
    INFORMATION_DISCLOSURE = "INFORMATION_DISCLOSURE"
    DENIAL_OF_SERVICE = "DENIAL_OF_SERVICE"

@dataclass
class Vulnerability:
    """
    Represents a single vulnerability found in solar inverter systems.
    
    This dataclass follows backend development best practices by using
    type hints and providing a clear data structure for vulnerability data.
    """
    cve_id: str
    title: str
    description: str
    severity: SeverityLevel
    cvss_score: float
    vulnerability_type: VulnerabilityType
    affected_components: List[str]
    affected_protocols: List[str]
    manufacturer: str
    model: str
    firmware_versions: List[str]
    discovery_date: datetime
    publication_date: datetime
    mitigation_available: bool
    mitigation_description: Optional[str] = None
    exploit_available: bool = False
    references: List[str] = None
    
    def __post_init__(self):
        """Initialize default values after object creation."""
        if self.references is None:
            self.references = []
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary for JSON serialization."""
        data = asdict(self)
        # Convert datetime objects to ISO format strings
        data['discovery_date'] = self.discovery_date.isoformat()
        data['publication_date'] = self.publication_date.isoformat()
        # Convert enums to string values
        data['severity'] = self.severity.value
        data['vulnerability_type'] = self.vulnerability_type.value
        return data
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Vulnerability':
        """Create vulnerability object from dictionary."""
        # Convert string dates back to datetime objects
        data['discovery_date'] = datetime.fromisoformat(data['discovery_date'])
        data['publication_date'] = datetime.fromisoformat(data['publication_date'])
        # Convert string enums back to enum objects
        data['severity'] = SeverityLevel(data['severity'])
        data['vulnerability_type'] = VulnerabilityType(data['vulnerability_type'])
        return cls(**data)

class CVEDatabase:
    """
    Manages CVE (Common Vulnerabilities and Exposures) database for solar inverters.
    
    This class demonstrates backend concepts like:
    - Data persistence and caching
    - API integration with external services
    - Error handling and retry logic
    - Data validation and sanitization
    """
    
    def __init__(self, cache_dir: str = "data/vulnerabilities"):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.cache_file = self.cache_dir / "cve_cache.json"
        self.vulnerabilities: List[Vulnerability] = []
        self._load_cache()
    
    def _load_cache(self) -> None:
        """Load cached vulnerability data from local storage."""
        try:
            if self.cache_file.exists():
                with open(self.cache_file, 'r') as f:
                    cached_data = json.load(f)
                self.vulnerabilities = [
                    Vulnerability.from_dict(vuln_data) 
                    for vuln_data in cached_data
                ]
                logger.info(f"Loaded {len(self.vulnerabilities)} vulnerabilities from cache")
        except Exception as e:
            logger.error(f"Error loading cache: {e}")
            self.vulnerabilities = []
    
    def _save_cache(self) -> None:
        """Save vulnerability data to local cache."""
        try:
            cache_data = [vuln.to_dict() for vuln in self.vulnerabilities]
            with open(self.cache_file, 'w') as f:
                json.dump(cache_data, f, indent=2)
            logger.info(f"Saved {len(self.vulnerabilities)} vulnerabilities to cache")
        except Exception as e:
            logger.error(f"Error saving cache: {e}")
    
    def fetch_solar_inverter_cves(self, manufacturers: List[str] = None) -> int:
        """
        Fetch CVE data for solar inverter manufacturers.
        
        Args:
            manufacturers: List of manufacturer names to search for
            
        Returns:
            Number of new vulnerabilities found
        """
        if manufacturers is None:
            manufacturers = [
                "sungrow", "fronius", "sma", "solaredge", "enphase",
                "abb", "schneider", "delta", "growatt", "goodwe"
            ]
        
        new_vulnerabilities = []
        
        # Simulate CVE database queries (in real implementation, use NIST NVD API)
        sample_vulnerabilities = self._generate_sample_vulnerabilities(manufacturers)
        
        for vuln in sample_vulnerabilities:
            if not self._vulnerability_exists(vuln.cve_id):
                new_vulnerabilities.append(vuln)
                self.vulnerabilities.append(vuln)
        
        if new_vulnerabilities:
            self._save_cache()
            logger.info(f"Found {len(new_vulnerabilities)} new vulnerabilities")
        
        return len(new_vulnerabilities)
    
    def _vulnerability_exists(self, cve_id: str) -> bool:
        """Check if vulnerability already exists in database."""
        return any(vuln.cve_id == cve_id for vuln in self.vulnerabilities)
    
    def _generate_sample_vulnerabilities(self, manufacturers: List[str]) -> List[Vulnerability]:
        """
        Generate sample vulnerabilities for demonstration purposes.
        In a real implementation, this would query actual CVE databases.
        """
        sample_vulns = []
        base_date = datetime.now() - timedelta(days=365)
        
        # Sample vulnerabilities based on research findings
        vuln_templates = [
            {
                "cve_id": "CVE-2023-1001",
                "title": "Sungrow WiNet-S Hardcoded MQTT Credentials",
                "description": "Hardcoded MQTT credentials found in Sungrow WiNet-S communication module firmware",
                "severity": SeverityLevel.HIGH,
                "cvss_score": 8.1,
                "vulnerability_type": VulnerabilityType.HARDCODED_SECRETS,
                "affected_components": ["WiNet-S Communication Module"],
                "affected_protocols": ["MQTT"],
                "manufacturer": "sungrow",
                "model": "WiNet-S",
                "firmware_versions": ["1.0.0", "1.0.1", "1.0.2"]
            },
            {
                "cve_id": "CVE-2023-1002", 
                "title": "Default Admin Credentials in Solar Inverter Web Interface",
                "description": "Default admin/admin credentials allow unauthorized access to inverter configuration",
                "severity": SeverityLevel.CRITICAL,
                "cvss_score": 9.8,
                "vulnerability_type": VulnerabilityType.DEFAULT_CREDENTIALS,
                "affected_components": ["Web Management Interface"],
                "affected_protocols": ["HTTP", "HTTPS"],
                "manufacturer": "generic",
                "model": "Multiple Models",
                "firmware_versions": ["Various"]
            },
            {
                "cve_id": "CVE-2023-1003",
                "title": "Unencrypted Modbus Communication",
                "description": "Modbus protocol implementation lacks encryption, allowing command injection",
                "severity": SeverityLevel.HIGH,
                "cvss_score": 7.5,
                "vulnerability_type": VulnerabilityType.INSECURE_PROTOCOL,
                "affected_components": ["Modbus Interface"],
                "affected_protocols": ["Modbus TCP", "Modbus RTU"],
                "manufacturer": "multiple",
                "model": "Industrial Inverters",
                "firmware_versions": ["Legacy versions"]
            }
        ]
        
        for i, template in enumerate(vuln_templates):
            discovery_date = base_date + timedelta(days=i*30)
            publication_date = discovery_date + timedelta(days=7)
            
            vuln = Vulnerability(
                cve_id=template["cve_id"],
                title=template["title"],
                description=template["description"],
                severity=template["severity"],
                cvss_score=template["cvss_score"],
                vulnerability_type=template["vulnerability_type"],
                affected_components=template["affected_components"],
                affected_protocols=template["affected_protocols"],
                manufacturer=template["manufacturer"],
                model=template["model"],
                firmware_versions=template["firmware_versions"],
                discovery_date=discovery_date,
                publication_date=publication_date,
                mitigation_available=True,
                mitigation_description="Update to latest firmware version",
                exploit_available=False,
                references=[f"https://example.com/advisory/{template['cve_id']}"]
            )
            sample_vulns.append(vuln)
        
        return sample_vulns
    
    def query_by_severity(self, min_severity: SeverityLevel) -> List[Vulnerability]:
        """Query vulnerabilities by minimum severity level."""
        severity_order = {
            SeverityLevel.INFORMATIONAL: 0,
            SeverityLevel.LOW: 1,
            SeverityLevel.MEDIUM: 2,
            SeverityLevel.HIGH: 3,
            SeverityLevel.CRITICAL: 4
        }
        
        min_level = severity_order[min_severity]
        return [
            vuln for vuln in self.vulnerabilities
            if severity_order[vuln.severity] >= min_level
        ]
    
    def query_by_manufacturer(self, manufacturer: str) -> List[Vulnerability]:
        """Query vulnerabilities for specific manufacturer."""
        return [
            vuln for vuln in self.vulnerabilities
            if manufacturer.lower() in vuln.manufacturer.lower()
        ]
    
    def query_by_protocol(self, protocol: str) -> List[Vulnerability]:
        """Query vulnerabilities affecting specific communication protocol."""
        return [
            vuln for vuln in self.vulnerabilities
            if any(protocol.lower() in p.lower() for p in vuln.affected_protocols)
        ]

class ProtocolAnalyzer:
    """
    Analyzes communication protocol security in solar inverter systems.
    
    This class demonstrates backend security concepts:
    - Protocol analysis and security assessment
    - Network communication evaluation
    - Security configuration validation
    """
    
    def __init__(self):
        self.supported_protocols = {
            "modbus": self._analyze_modbus,
            "mqtt": self._analyze_mqtt,
            "http": self._analyze_http,
            "https": self._analyze_https,
            "tls": self._analyze_tls
        }
    
    def analyze_protocol_security(self, protocol: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze security configuration of a specific protocol.
        
        Args:
            protocol: Protocol name (modbus, mqtt, http, etc.)
            config: Protocol configuration parameters
            
        Returns:
            Security analysis results
        """
        protocol_lower = protocol.lower()
        
        if protocol_lower not in self.supported_protocols:
            raise ValueError(f"Unsupported protocol: {protocol}")
        
        return self.supported_protocols[protocol_lower](config)
    
    def _analyze_modbus(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze Modbus protocol security."""
        issues = []
        recommendations = []
        
        # Check for encryption
        if not config.get('encryption_enabled', False):
            issues.append("Modbus communication not encrypted")
            recommendations.append("Implement Modbus/TCP with TLS encryption")
        
        # Check authentication
        if not config.get('authentication_required', False):
            issues.append("No authentication required for Modbus access")
            recommendations.append("Implement device authentication")
        
        # Check access controls
        if config.get('open_access', True):
            issues.append("Modbus interface allows unrestricted access")
            recommendations.append("Implement IP whitelisting and access controls")
        
        return {
            "protocol": "modbus",
            "security_score": max(0, 10 - len(issues) * 3),
            "issues": issues,
            "recommendations": recommendations,
            "risk_level": "HIGH" if len(issues) >= 2 else "MEDIUM"
        }
    
    def _analyze_mqtt(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze MQTT protocol security."""
        issues = []
        recommendations = []
        
        # Check TLS encryption
        if not config.get('tls_enabled', False):
            issues.append("MQTT communication not encrypted")
            recommendations.append("Enable MQTT over TLS (port 8883)")
        
        # Check authentication
        if not config.get('username_password', False):
            issues.append("No username/password authentication")
            recommendations.append("Implement strong authentication")
        
        # Check certificate validation
        if config.get('tls_enabled') and not config.get('cert_validation', False):
            issues.append("TLS certificate validation disabled")
            recommendations.append("Enable proper certificate validation")
        
        return {
            "protocol": "mqtt",
            "security_score": max(0, 10 - len(issues) * 2.5),
            "issues": issues,
            "recommendations": recommendations,
            "risk_level": "HIGH" if len(issues) >= 3 else "MEDIUM"
        }
    
    def _analyze_http(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze HTTP protocol security."""
        issues = []
        recommendations = []
        
        # HTTP is inherently insecure
        issues.append("HTTP transmits data in plaintext")
        recommendations.append("Migrate to HTTPS with valid TLS certificates")
        
        # Check authentication
        if config.get('basic_auth', False):
            issues.append("Basic authentication over HTTP is insecure")
            recommendations.append("Use secure authentication over HTTPS")
        
        return {
            "protocol": "http",
            "security_score": 2,  # HTTP gets low score by default
            "issues": issues,
            "recommendations": recommendations,
            "risk_level": "HIGH"
        }
    
    def _analyze_https(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze HTTPS/TLS protocol security."""
        issues = []
        recommendations = []
        
        # Check TLS version
        tls_version = config.get('tls_version', '1.0')
        if tls_version in ['1.0', '1.1']:
            issues.append(f"Outdated TLS version {tls_version}")
            recommendations.append("Upgrade to TLS 1.2 or 1.3")
        
        # Check certificate validation
        if not config.get('cert_validation', True):
            issues.append("Certificate validation disabled")
            recommendations.append("Enable proper certificate validation")
        
        # Check cipher suites
        if config.get('weak_ciphers', False):
            issues.append("Weak cipher suites enabled")
            recommendations.append("Disable weak ciphers and use strong encryption")
        
        return {
            "protocol": "https",
            "security_score": max(0, 9 - len(issues) * 2),
            "issues": issues,
            "recommendations": recommendations,
            "risk_level": "LOW" if len(issues) == 0 else "MEDIUM"
        }
    
    def _analyze_tls(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze TLS configuration security."""
        return self._analyze_https(config)  # TLS analysis is similar to HTTPS

